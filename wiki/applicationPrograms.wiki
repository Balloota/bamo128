#summary bamo128 and arduino sketches or C/C++/asm - application programs

You can upload application programs bamo128 from the arduino IDE or with the 'w' and 'W' - command from monitor. Programs are loaded at flash address 0 normally.<br>
This application programs overwrite the interrupt vector table at address 0 and if you activate the timer1 form bamo128 in "mainloop.asm" the system crashes because interrupts are no more catched in the interrupt service routine of bamo128. <br>
It crashes also, if you use the monitor 's' (step) or 'x'(start with breakpoint because it is realized with time2 interrupt in bamo128.<br>
But you can avoid this, if you in your C/C++/Arduino-sourcecode insert this lines (for atmega1280 or atmega328):<br>
{{{
#define	BYTES(word)	((word)*2)
#define	STRING(a,b)	#a" "#b
#define	INLINEASM(a,b)	STRING(a,b)

#ifdef  __AVR_ATmega1280__		// arduinoMega
#define	LARGEBOOTSTART	0xf000
#define	BOARDRAMEND	0x2200
#define	MONSTART	LARGEBOOTSTART
#elif __AVR_ATmega328P__		// arduinoDuemilanove
#define	LARGEBOOTSTART	0x3000
#define	BOARDRAMEND	0x900
#define	MONSTART	LARGEBOOTSTART
#endif	
#define MONRAM		(BOARDRAMEND-0x100)
#define	SYSTIMEMILLISEC	(MONRAM+0x40)
#define saveCPU		BYTES(LARGEBOOTSTART+62)	// time2Comp interrupt
#define mySysClock      BYTES(LARGEBOOTSTART+56)	// timer1 overflow int

// monitor interrupt f√ºr step ...
ISR(TIMER2_COMPA_vect) __attribute__ ((naked));
ISR(TIMER2_COMPA_vect) {asm volatile  (INLINEASM(jmp,saveCPU));}

 /* monitor interrupt for sysclock millisec */
ISR(TIMER1_COMPA_vect) __attribute__ ((naked));
ISR(TIMER1_COMPA_vect) {asm volatile  (INLINEASM(jmp,mySysClock));}
}}}
In asm set equivalent jump entries for interrupts with '.org' pseudo code directives.<br>
The monitor needs 256 bytes ram. Sketches/C/C++ programs use the whole ram with the stacksegment in the upper part normally. You can shift the stacksegment downwards:
{{{
void code_init2() __attribute__ ((naked, section (".init2")));

/* !!! never call this function !!! */
void code_init2 (void)
{
#ifdef __AVR_ATmega1280__		// arduinoMega
   SP = 0x2100;
#elif __AVR_ATmega328P__		// arduinoDuemilanove
   SP = 0x800; 
#endif
}
}}}
an equivalent effect (arduinoMega) you get with a linker option:<br>
-Wl,--defsym=__stack=0x802100<br>
and you save the monitor variables for overwriting. With "return" the application programs go back to the monitor.
=== Use of monitor functions and variables in application programs===
The monitor contains useful variables and functions e.g. currentTimeMilliSec
or conIn and conOut, the serial byte input and output.<br>
You can use many in your application program.<br>
Most public functions are C/C++ compatible (parameter passing, return value, use of registers,...).<br>
Your sketch, C/C++ or asm program must make known this variables and functions over addresses.<br>
Bamo128 contains a jump table to this functions at the beginning (see bamo128.asm). So application can use fix addresses even if the monitor is updated and routines disarranges in monitor.<br>
You can use a linker script to tell the linker where useful functions/variables are im monitor:<br>
Example linkerscript link1280.lds for atmega1280:
{{{ 
/* hi this is a linker script */
/* monitor functions for C applications */
mainLoop	= 0x1e004;	
/* (LARGEBOOTSTART+2) ; Ruecksprung in Monitor aus Programm mit "ret" */
conIn		= 0x1e008; 	/* (LARGEBOOTSTART+4) */
conOut		= 0x1e00c;	/* (LARGEBOOTSTART+6) */
conStatInT	= 0x1e010;	/* (LARGEBOOTSTART+8) */
outFlashText 	= 0x1e018;	/* (LARGEBOOTSTART+12) */
exit 		= 0x1e004;	/* mainLoop */
saveCPU		= 0x1e07c;	/* saveCPU step mod */
mySysClock	= 0x1e070;	/* timer ms  F056*/
startTimer1	= 0x1e074;      /* (LARGEBOOTSTART+58) */

sysTime		= 0x7f40;	/* systime milliSec 4 bytes little endian */
}}}
(The GNU environment works with byte addresses and the linker scripts runs not trough the preprocessor.)<br><br>
Another possibility is to tell the compiler what addresses are used:
{{{
char (*conIn)()		=(void*)(LARGEBOOTSTART+4);
void (*conOut)(char)	=(void*)(LARGEBOOTSTART+6);
#define	SYSTIMEMILLISEC	(MONRAM+0x40)
}}}